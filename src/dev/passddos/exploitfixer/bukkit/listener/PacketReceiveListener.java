package dev._2lstudios.exploitfixer.bukkit.listener;

import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.Map;
import java.util.Map.Entry;

import org.bukkit.GameMode;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.Cancellable;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryType;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.InventoryView;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.plugin.Plugin;

import dev._2lstudios.exploitfixer.bukkit.exploit.BukkitExploitPlayer;
import dev._2lstudios.exploitfixer.bukkit.managers.ExploitPlayerManager;
import dev._2lstudios.exploitfixer.bukkit.managers.ModuleManager;
import dev._2lstudios.exploitfixer.bukkit.modules.BukkitNotificationsModule;
import dev._2lstudios.exploitfixer.bukkit.modules.ItemsFixModule;
import dev._2lstudios.exploitfixer.bukkit.utils.ExploitUtil;
import dev._2lstudios.exploitfixer.shared.modules.PacketsModule;
import dev._2lstudios.hamsterapi.enums.PacketType;
import dev._2lstudios.hamsterapi.events.PacketReceiveEvent;
import dev._2lstudios.hamsterapi.hamsterplayer.HamsterPlayer;
import dev._2lstudios.hamsterapi.wrappers.PacketWrapper;

public class PacketReceiveListener implements Listener {
    private final Plugin plugin;
    private final ExploitUtil exploitUtil;
    private final ExploitPlayerManager exploitPlayerManager;
    private final ItemsFixModule itemsFixModule;
    private final BukkitNotificationsModule notificationsModule;
    private final PacketsModule packetsModule;

    PacketReceiveListener(final Plugin plugin, final ExploitUtil exploitUtil, final ModuleManager moduleManager) {
        this.plugin = plugin;
        this.exploitUtil = exploitUtil;
        this.exploitPlayerManager = moduleManager.getExploitPlayerManager();
        this.itemsFixModule = moduleManager.getItemsFixModule();
        this.notificationsModule = moduleManager.getNotificationsModule();
        this.packetsModule = moduleManager.getPacketsModule();
    }

    public void onPacketReceive(final Cancellable event, final HamsterPlayer hamsterPlayer, final Player player,
            final PacketWrapper packetWrapper) {
        final PacketType packetType = packetWrapper.getType();

        if (packetType != PacketType.PacketPlayInKeepAlive && packetsModule.isEnabled()) {
            final Map<String, String> strings = packetWrapper.getStrings();
            final BukkitExploitPlayer exploitPlayer = exploitPlayerManager.get(player);
            final String playerName = player.getName();
            final String packetName = packetWrapper.getName();
            final double dataVls = packetsModule.getDataVls();
            final Map<String, Integer> integers = packetWrapper.getIntegers();
            final InventoryView inventoryView = player.getOpenInventory();
            final double windowClick = packetsModule.getWindowClick();
            final double setCreativeSlot = packetsModule.getSetCreativeSlot();
            final int dataBytesSigns = packetsModule.getDataBytesSign();

            if (packetType == PacketType.PacketPlayInCustomPayload) {
                if (!strings.isEmpty()) {
                    final String tag = strings.values().iterator().next();
                    final double tagVls = packetsModule.getTagVls();
                    final double bookVls = packetsModule.getBookVls();

                    if (tagVls > 0 && tag == null || tag.isEmpty()) {
                        final String reason = "[" + packetName + "|Tag] " + playerName
                                + " sent a CustomPayload packet without TAG! Added vls: " + tagVls;

                        exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, tagVls);
                        return;
                    } else if (bookVls > 0 && tag.equals("MC|BEdit") || tag.equals("MC|BSign")
                            || tag.equals("MC|BOpen")) {
                        final PlayerInventory playerInventory = player.getInventory();
                        final ItemStack itemInHand = playerInventory.getItem(playerInventory.getHeldItemSlot());

                        if (itemInHand != null && !itemInHand.getType().toString().contains("BOOK")) {
                            final String reason = "[" + packetName + "|Book] " + playerName + " tried to send a " + tag
                                    + " CustomPayload packet without a book in hand!";

                            exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, bookVls);
                            return;
                        }
                    }

                    exploitPlayer.addVls(plugin, event, hamsterPlayer, packetsModule, packetsModule.getMultiplier(tag));
                } else {
                    notificationsModule
                            .debug("[" + packetName + "] " + playerName + " sent a empty CustomPayload packet!");

                    event.setCancelled(true);
                }
            }

            if (windowClick > 0 && integers.containsKey("slot")) {
                final Inventory topInventory = inventoryView.getTopInventory();
                final Inventory bottomInventory = inventoryView.getBottomInventory();
                final int slot = integers.get("slot"), maxSlots;

                if (bottomInventory.getType() == InventoryType.PLAYER
                        && topInventory.getType() == InventoryType.CRAFTING) {
                    maxSlots = inventoryView.countSlots() + 4;
                } else {
                    maxSlots = inventoryView.countSlots();
                }

                if (slot < 0 && slot != -999 && slot != -1) {
                    final String reason = "[" + packetName + "|WindowClick] " + playerName
                            + " sent a slot less than 0 and not [-999 or -1]! Slot: " + slot + " Added vls: "
                            + windowClick;

                    exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, windowClick);
                    return;
                } else if (slot >= maxSlots) {
                    final String reason = "[" + packetName + "|WindowClick] " + playerName
                            + " exceeded max available slots! (" + slot + "/" + maxSlots + ") Added vls: "
                            + windowClick;

                    exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, windowClick);
                    return;
                }
            }

            if (setCreativeSlot > 0 && packetType == PacketType.PacketPlayInSetCreativeSlot
                    && player.getGameMode() != GameMode.CREATIVE) {
                final String reason = "[" + packetName + "|SetCreativeSlot] " + playerName
                        + " sent SET_CREATIVE_SLOT without CREATIVE! Added vls: " + setCreativeSlot;

                exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, setCreativeSlot);
                return;
            }

            int packetSize = 0;

            if (dataVls > 0) {
                final Map<String, Object> objects = packetWrapper.getObjects();
                final int dataBytes = packetsModule.getDataBytes();

                try {
                    if (!objects.isEmpty()) {
                        final Collection<Object> objectsValues = objects.values();

                        for (final Object object : objectsValues) {
                            if (object instanceof ItemStack) {
                                packetSize += exploitUtil.parseItemLength((ItemStack) object, exploitPlayer,
                                        hamsterPlayer, packetName, dataBytes);
                            } else {
                                packetSize += String.valueOf(object).getBytes(StandardCharsets.UTF_8).length;
                            }
                        }
                    }
                } catch (final Exception exception) {
                    final String reason = "[" + packetName + "|Data] " + playerName
                            + " has sent an unparseable packet! Added vls: " + dataVls;

                    exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls);
                    return;
                }

                if (dataBytes > 0 && packetSize > dataBytes) {
                    final String reason = "[" + packetName + "|Data] " + playerName + " sent a packet of " + packetSize
                            + " bytes long!";

                    exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls);
                    return;
                }

                if (dataBytesSigns > 0 && packetType == PacketType.PacketPlayInUpdateSign
                        && exploitUtil.parseSign(strings.values().toArray(new String[0]))) {
                    final String reason = "[" + packetName + "|Data] " + playerName
                            + " has sent a too big sign packet! Added vls: " + dataVls;

                    exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls);
                    return;
                }
            }

            final double bytesDividerAddition = packetSize / packetsModule.getDataBytesDivider();

            exploitPlayer.addVls(plugin, event, hamsterPlayer, packetsModule,
                    packetsModule.getMultiplier(packetName) + bytesDividerAddition);
        }

        if (packetType == PacketType.PacketPlayInSetCreativeSlot && itemsFixModule.isEnabled()) {
            final Map<String, ItemStack> items = packetWrapper.getItems();

            for (final Entry<String, ItemStack> itemsEntry : items.entrySet()) {
                final ItemStack itemStack = itemsEntry.getValue();

                if (itemStack != null) {
                    final String blacklisted = exploitUtil.clearIfBlacklisted(itemStack);

                    if (blacklisted != null) {
                        packetWrapper.write(itemsEntry.getKey(), new ItemStack(Material.AIR));
                        notificationsModule.debug(
                                player.getName() + " had a creative item blacklisted by ExploiFixer! (" + blacklisted + ")");
                    } else {
                        packetWrapper.write(itemsEntry.getKey(), itemsFixModule.fixItem(itemStack));
                        notificationsModule.debug(player.getName() + " had a creative item fixed by ExploiFixer!");
                    }
                }
            }
        }

        notificationsModule.addPacketDebug(String.valueOf(packetType));
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.LOWEST)
    public void onPacketReceive(final PacketReceiveEvent event) {
        final HamsterPlayer hamsterPlayer = event.getHamsterPlayer();

        onPacketReceive(event, hamsterPlayer, hamsterPlayer.getPlayer(), event.getPacket());
    }
}